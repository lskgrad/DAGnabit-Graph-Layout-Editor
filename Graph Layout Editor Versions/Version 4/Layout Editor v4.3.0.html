<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Layout Editor — Multi-Plate Stable (Nested Plates)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin:0; font-family: sans-serif; display:flex; height:100vh; }
    #sidebar {
      width: 220px; background: #f7f7f7; padding: 12px; border-right: 1px solid #ccc;
      box-sizing: border-box; display:flex; flex-direction:column; justify-content:space-between;
    }
    #controls {}
    label, button, input { display:block; width:100%; margin:6px 0; box-sizing:border-box; }
    #graph { flex:1; }
    svg { width:100%; height:100%; background:#fff; display:block; }
    .plate-rect { fill: rgba(200,200,255,0.14); stroke: rgba(80,80,200,0.8); stroke-width:1.5px; rx:8; ry:8; }
    .plate-label { font-size:12px; fill: rgba(40,40,100,0.9); pointer-events:none; }
    .node-ellipse { fill:#69b3a2; stroke:#333; stroke-width:1.5px; }
    .node-text { font-size:14px; fill:#000; pointer-events:none; text-anchor:middle; dominant-baseline:central; }
    .link-line { stroke-width:1.5px; marker-end: url(#arrow); }
    .legend-item { display:flex; align-items:center; gap:8px; font-size:13px; margin:6px 0; }
    .legend-color { width:20px; height:8px; }
    /* Slight visual cue for plate label when deeper */
    .plate-label.depth-0 { font-weight:700; }
  </style>
</head>
<body>
  <div id="sidebar">
    <div id="controls">
      <button id="fitView">Fit to view</button>
      <label for="gridSpacing">Grid spacing</label>
      <input id="gridSpacing" type="number" value="5" min="1"/>
      <label for="nodeFile">Nodes CSV (Plates use semicolons; use / for nesting)</label>
      <input id="nodeFile" type="file" accept=".csv"/>
      <label for="edgeFile">Edges CSV</label>
      <input id="edgeFile" type="file" accept=".csv"/>
      <button id="loadGraph">Load Graph</button>

      <div style="margin-top:8px;">
        <div style="position:relative;">
          <button id="exportBtn">Export ▼</button>
          <div id="exportMenu" style="display:none; position:absolute; left:0; top:36px; background:#fff; border:1px solid #ccc; box-shadow:0 2px 6px rgba(0,0,0,0.15); width:100%;">
            <button id="exportSVG" style="border:none; background:none; padding:8px; text-align:left; width:100%;">Export SVG</button>
            <button id="exportPNG" style="border:none; background:none; padding:8px; text-align:left; width:100%;">Export PNG</button>
          </div>
        </div>
      </div>
    </div>

    <div id="legend" style="margin-top:10px; border-top:1px solid #ddd; padding-top:8px;">
      <div style="font-weight:600; text-align:center; margin-bottom:6px;">Legend</div>
      <div class="legend-item"><div class="legend-color" style="background:blue"></div> Logical</div>
      <div class="legend-item"><div class="legend-color" style="background:red"></div> Stochastic</div>
      <div style="font-size:12px; color:#555; margin-top:6px;">Plates: separate multiple plates with semicolons. For nesting use <code>Outer/Inner</code>.</div>
    </div>
  </div>

  <div id="graph"></div>

  <script>
    const sidebarWidth = 220;
    let width = window.innerWidth - sidebarWidth;
    let height = window.innerHeight;
    const svg = d3.select("#graph").append("svg").attr("width", width).attr("height", height);

    // defs
    const defs = svg.append("defs");
    defs.append("marker")
      .attr("id","arrow").attr("viewBox","0 -5 10 10").attr("refX",10).attr("refY",0)
      .attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto")
      .append("path").attr("d","M0,-5L10,0L0,5").attr("fill","#999");

    const mainGroup = svg.append("g");
    const platesGroup = mainGroup.append("g").attr("class","plates");
    const linksGroup = mainGroup.append("g").attr("class","links");
    const nodesGroup = mainGroup.append("g").attr("class","nodes");

    const zoom = d3.zoom().on("zoom", (event)=> mainGroup.attr("transform", event.transform));
    svg.call(zoom);

    let nodes = [];   // {id,x,y,rx,ry,platesPaths:[], platesRaw}
    let links = [];   // {source:nodeObj, target:nodeObj, type}
    let plateMap = new Map(); // fullPath -> plateObj
    let plates = []; // flattened list of plate objects for rendering (sorted by depth)

    function getEdgeColor(type) {
      return type === "logical" ? "blue" : type === "stochastic" ? "red" : "#999";
    }

    function computeTextSizes(arr) {
      const ctx = document.createElement("canvas").getContext("2d");
      ctx.font = "14px sans-serif";
      arr.forEach(d => {
        const w = ctx.measureText(d.id).width;
        d.rx = Math.max(24, w/2 + 12);
        d.ry = 16;
      });
    }

    // --- Plate structure utilities ---
    // Plate object: { fullPath, name, parent (fullPath or null), children:[], nodes:[], x,y,width,height,padding,depth }
    function resetPlates() {
      plateMap = new Map();
      plates = [];
    }

    function ensurePlate(fullPath) {
      if (!fullPath) return null;
      if (plateMap.has(fullPath)) return plateMap.get(fullPath);
      const parts = fullPath.split("/");
      const name = parts[parts.length - 1];
      const parentPath = parts.length > 1 ? parts.slice(0, -1).join("/") : null;
      const plate = { fullPath, name, parentPath, children: [], nodes: [], x:0, y:0, width:0, height:0, padding:18, depth: parentPath ? (ensurePlate(parentPath).depth + 1) : 0 };
      plateMap.set(fullPath, plate);
      // if parent exists, attach as child
      if (parentPath) {
        const parent = ensurePlate(parentPath);
        if (!parent.children.includes(plate.fullPath)) parent.children.push(plate.fullPath);
      }
      return plate;
    }

    function buildPlatesFromNodes() {
      resetPlates();
      nodes.forEach(n => {
        // platesRaw may contain semicolon-separated plate specs. Each plate spec may be nested via '/'
        const raw = (n.plateRaw || "").toString().trim();
        if (!raw || raw.toLowerCase() === "none") {
          n.platesPaths = [];
          return;
        }
        const specs = raw.split(";").map(s => s.trim()).filter(Boolean);
        n.platesPaths = [];
        specs.forEach(spec => {
          // spec may be nested like Outer/Inner
          const fullPath = spec;
          // create all ancestors
          const parts = fullPath.split("/");
          for (let i=1;i<=parts.length;i++){
            const p = parts.slice(0,i).join("/");
            ensurePlate(p);
          }
          // add node into deepest plate (the fullPath)
          const plate = ensurePlate(fullPath);
          plate.nodes.push(n);
          n.platesPaths.push(fullPath);
        });
      });

      // Ensure plates array is sorted by depth ascending (roots first) for rendering and collision checks
      plates = Array.from(plateMap.values()).sort((a,b)=>a.depth - b.depth || a.fullPath.localeCompare(b.fullPath));
      // Also ensure children arrays are unique
      plates.forEach(p => { p.children = Array.from(new Set(p.children)); });
    }

    // compute bounds recursively: leafs based on their nodes, then include child plates
    function recomputePlateBounds() {
      // compute per-plate bounding box recursively: we'll process deepest plates first
      const platesByDepthDesc = Array.from(plateMap.values()).sort((a,b)=>b.depth - a.depth);
      platesByDepthDesc.forEach(p => {
        const pad = p.padding || 18;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        // nodes directly assigned to this plate
        (p.nodes || []).forEach(n => {
          minX = Math.min(minX, n.x - n.rx);
          minY = Math.min(minY, n.y - n.ry);
          maxX = Math.max(maxX, n.x + n.rx);
          maxY = Math.max(maxY, n.y + n.ry);
        });
        // include child plates' bounds
        (p.children || []).forEach(childPath => {
          const c = plateMap.get(childPath);
          if (c && c.width !== undefined) {
            minX = Math.min(minX, c.x);
            minY = Math.min(minY, c.y);
            maxX = Math.max(maxX, c.x + c.width);
            maxY = Math.max(maxY, c.y + c.height);
          }
        });
        if (minX === Infinity) {
          // no content — leave previous bounds (or set default small)
          if (!p.width || !p.height) {
            p.x = p.x || 0;
            p.y = p.y || 0;
            p.width = p.width || 40;
            p.height = p.height || 30;
          }
        } else {
          p.x = minX - pad;
          p.y = minY - pad;
          p.width = Math.max(10, (maxX - minX) + pad*2);
          p.height = Math.max(10, (maxY - minY) + pad*2);
        }
      });
    }

    // Helper: rectangle overlap
    function rectsOverlap(a, b) {
      return !(a.x + a.width <= b.x || b.x + b.width <= a.x || a.y + a.height <= b.y || b.y + b.height <= a.y);
    }

    // Helper: check point inside plate (strict interior)
    function pointInPlate(px, py, plate) {
      return px > plate.x && px < (plate.x + plate.width) && py > plate.y && py < (plate.y + plate.height);
    }

    // Helper: get plate ancestors chain (fullPath strings)
    function getPlateAncestors(plate) {
      const list = [];
      let cur = plate;
      while (cur && cur.parentPath) {
        list.unshift(cur.parentPath);
        cur = plateMap.get(cur.parentPath);
      }
      return list;
    }

    // --- Drawing & interactions ---
    function updatePlatesSelection() {
      // render plates sorted by depth ascending so roots are behind children
      plates = Array.from(plateMap.values()).sort((a,b)=>a.depth - b.depth || a.fullPath.localeCompare(b.fullPath));
      // bind by fullPath
      const sel = platesGroup.selectAll("g.plate").data(plates, d => d.fullPath);
      sel.exit().remove();

      const enter = sel.enter().append("g").attr("class","plate")
        .call(d3.drag()
          .on("start", (e,d) => { d.__start = { x:d.x, y:d.y }; })
          .on("drag", (e,d) => {
            const dx = e.dx, dy = e.dy;
            const newBounds = { x: d.x + dx, y: d.y + dy, width: d.width, height: d.height };

            // Constraint: if has parent, plate must remain entirely inside parent
            if (d.parentPath) {
              const parent = plateMap.get(d.parentPath);
              if (!parent) return;
              if (!(newBounds.x >= parent.x && newBounds.y >= parent.y &&
                    newBounds.x + newBounds.width <= parent.x + parent.width &&
                    newBounds.y + newBounds.height <= parent.y + parent.height)) {
                return; // cancel move — would escape parent
              }
            } else {
              // root plates: prevent moving outside canvas bounds? optional — allow anywhere for now
            }

            // Constraint: not overlapping siblings
            const siblings = (d.parentPath ? plateMap.get(d.parentPath).children : plates.filter(p=>!p.parentPath).map(p=>p.fullPath));
            const overlapWithSibling = siblings.some(sPath => {
              if (sPath === d.fullPath) return false;
              const s = plateMap.get(sPath);
              if (!s) return false;
              return rectsOverlap(newBounds, s);
            });
            if (overlapWithSibling) return;

            // Apply translation to this plate and to all descendants (plates and nodes)
            const translateDescendants = (plateObj, tx, ty) => {
              // move plate
              plateObj.x += tx; plateObj.y += ty;
              // move nodes of this plate
              (plateObj.nodes || []).forEach(n => { n.x += tx; n.y += ty; });
              // recursively move children plates
              (plateObj.children || []).forEach(childPath => {
                const child = plateMap.get(childPath);
                if (child) translateDescendants(child, tx, ty);
              });
            };
            translateDescendants(d, dx, dy);

            // immediate visual updates
            updatePlatesTransform();
            nodesGroup.selectAll("g.node").attr("transform", n => `translate(${n.x},${n.y})`);
            updateLinksPositions();
          })
          .on("end", (e,d) => {
            const spacing = +document.getElementById("gridSpacing").value || 5;
            // snap this plate and descendants to grid
            const snapPlate = (pObj) => {
              // snap plate.x/y to grid relative to current absolute coords
              pObj.x = Math.round(pObj.x / spacing) * spacing;
              pObj.y = Math.round(pObj.y / spacing) * spacing;
              (pObj.nodes||[]).forEach(n => {
                n.x = Math.round(n.x / spacing) * spacing;
                n.y = Math.round(n.y / spacing) * spacing;
              });
              (pObj.children||[]).forEach(childPath => {
                const ch = plateMap.get(childPath);
                if (ch) snapPlate(ch);
              });
            };
            snapPlate(d);
            recomputePlateBounds();
            updatePlatesTransform();
            nodesGroup.selectAll("g.node").attr("transform", n => `translate(${n.x},${n.y})`);
            updateLinksPositions();
            delete d.__start;
          })
        );

      enter.append("rect").attr("class","plate-rect");
      enter.append("text").attr("class","plate-label").attr("x",8).attr("y",14);

      // update label text and style
      platesGroup.selectAll("g.plate").each(function(p){
        const g = d3.select(this);
        g.select("text").text(p.name).attr("class", `plate-label depth-${p.depth}`);
        // style rect fill darker for deeper plates
        const baseAlpha = 0.14;
        // create a slightly darker fill for each depth level by increasing alpha and darkening color
        const alpha = Math.min(0.6, baseAlpha + p.depth * 0.08);
        const fill = `rgba(170,180,240,${alpha})`;
        const strokeWidth = 1.5 + Math.min(2, p.depth * 0.4);
        g.select("rect").attr("fill", fill).attr("stroke-width", strokeWidth);
      });

      updatePlatesTransform();
    }

    function updatePlatesTransform() {
      platesGroup.selectAll("g.plate")
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .each(function(d){
          d3.select(this).select("rect").attr("width", Math.max(10, d.width)).attr("height", Math.max(10, d.height));
        });
    }

    function updateLinksPositions() {
      linksGroup.selectAll("line").data(links, d => `${d.source.id}→${d.target.id}`)
        .join(
          enter => enter.append("line")
                        .attr("class","link-line")
                        .attr("stroke", d => getEdgeColor(d.type))
                        .attr("marker-end","url(#arrow)"),
          update => update,
          exit => exit.remove()
        )
        .each(function(d){
          const [xt, yt] = computeEdgeEndpoint(d.source, d.target);
          d3.select(this).attr("x1", d.source.x).attr("y1", d.source.y).attr("x2", xt).attr("y2", yt);
        });
    }

    function computeEdgeEndpoint(src,tgt) {
      const dx = tgt.x - src.x, dy = tgt.y - src.y;
      const angle = Math.atan2(dy, dx);
      const px = tgt.x - tgt.rx * Math.cos(angle);
      const py = tgt.y - tgt.ry * Math.sin(angle);
      return [px, py];
    }

    function drawNodes() {
      const sel = nodesGroup.selectAll("g.node").data(nodes, d => d.id);
      sel.exit().remove();

      const enter = sel.enter().append("g")
        .attr("class","node")
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .call(d3.drag()
          .on("start", (e,d) => { d.__orig = { x: d.x, y: d.y }; })
          .on("drag", function(e,d){
            const old = {x:d.x, y:d.y};
            d.x = e.x; d.y = e.y;

            // Constraint: node must remain inside at least one of its assigned plates (if any),
            // and must not enter plates it's not assigned to.
            let insideAssigned = (d.platesPaths && d.platesPaths.length === 0) ? true : false;
            // if assignedPaths exist, check if d is inside any assigned plate (leaf)
            if (d.platesPaths && d.platesPaths.length > 0) {
              insideAssigned = d.platesPaths.some(pPath => {
                const plate = plateMap.get(pPath);
                return plate && pointInPlate(d.x, d.y, plate);
              });
            }

            // Check if node is inside any plate that it is NOT assigned to (i.e., foreign)
            const insideForeign = Array.from(plateMap.values()).some(p => {
              // if node assigned to this plate or any descendant of this plate, it's not foreign.
              const assignedContains = (d.platesPaths || []).some(ap => {
                return ap === p.fullPath || ap.startsWith(p.fullPath + "/") || p.fullPath.startsWith(ap + "/");
              });
              if (assignedContains) return false;
              return pointInPlate(d.x, d.y, p);
            });

            if (!insideAssigned || insideForeign) {
              // revert
              d.x = old.x; d.y = old.y;
              return;
            }

            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            updateLinksPositions();
            // moving node may affect plate bounds up the chain
            recomputePlateBounds();
            updatePlatesTransform();
          })
          .on("end", function(e,d){
            const spacing = +document.getElementById("gridSpacing").value || 5;
            d.x = Math.round(d.x / spacing) * spacing;
            d.y = Math.round(d.y / spacing) * spacing;
            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            recomputePlateBounds();
            updatePlatesTransform();
            updateLinksPositions();
          })
        );

      enter.append("ellipse").attr("class","node-ellipse");
      enter.append("text").attr("class","node-text");

      nodesGroup.selectAll("g.node").each(function(d){
        d3.select(this).select("ellipse").attr("rx", d.rx).attr("ry", d.ry);
        d3.select(this).select("text").text(d.id);
        d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
      });

      updateLinksPositions();
    }

    // --- Fit-to-view ---
    function fitToView() {
      const bbox = mainGroup.node().getBBox();
      if (!bbox || bbox.width === 0 || bbox.height === 0) {
        svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
        return;
      }
      const padding = 40;
      const scale = Math.min((width - padding)/bbox.width, (height - padding)/bbox.height);
      const tx = (width/2) - scale * (bbox.x + bbox.width/2);
      const ty = (height/2) - scale * (bbox.y + bbox.height/2);
      svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(scale));
    }

    // --- CSV parsing & load ---
    function parseCSVFile(file) {
      return new Promise((resolve,reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(d3.csvParse(e.target.result));
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    document.getElementById("loadGraph").addEventListener("click", async ()=>{
      const nf = document.getElementById("nodeFile").files[0];
      const ef = document.getElementById("edgeFile").files[0];
      if (!nf || !ef) { alert("Please upload nodes and edges CSV"); return; }
      const [nd, ed] = await Promise.all([parseCSVFile(nf), parseCSVFile(ef)]);

      // normalize node rows
      nodes = nd.map((r,i) => {
        const id = (r.id || r.ID || r.name || ("node"+i)).toString();
        const x = (r.x !== undefined && r.x !== "") ? +r.x : (100 + (i%4)*160);
        const y = (r.y !== undefined && r.y !== "") ? +r.y : (100 + Math.floor(i/4)*120);
        const plateRaw = (r.Plates !== undefined) ? r.Plates : (r.plates !== undefined ? r.plates : (r.Plate !== undefined ? r.Plate : ""));
        return { id, x, y, plateRaw: plateRaw ? plateRaw.toString() : "" };
      });

      computeTextSizes(nodes);

      // edges: allow various header names
      links = ed.map(e => {
        const src = (e.source || e.Source || e.src || e.SOURCE || "").toString();
        const tgt = (e.target || e.Target || e.dst || e.TARGET || "").toString();
        const type = ((e.type || e.Type || "")).toString().trim().toLowerCase();
        return { source: src, target: tgt, type: type || "default" };
      });

      // convert links to object refs
      links.forEach(l => {
        const s = nodes.find(n => n.id === l.source);
        const t = nodes.find(n => n.id === l.target);
        l.source = s || {id: l.source, x:0, y:0, rx:10, ry:10};
        l.target = t || {id: l.target, x:0, y:0, rx:10, ry:10};
      });

      // Build plates and attach nodes
      buildPlatesFromNodes();
      // Compute plate bounds
      recomputePlateBounds();
      // Draw plates, nodes, links
      updatePlatesSelection();
      drawNodes();
      updateLinksPositions();
      fitToView();
    });

    // --- Demo load on start ---
    function loadDemo() {
      nodes = [
        { id: "Alpha", plateRaw: "Outer", x:200, y:160 },
        { id: "Beta", plateRaw: "Outer/Inner", x:380, y:160 },
        { id: "Gamma", plateRaw: "Outer/Inner", x:380, y:320 },
        { id: "Delta", plateRaw: "Outer", x:200, y:320 },
        { id: "Epsilon", plateRaw: "OtherRoot", x:560, y:320 }
      ];
      computeTextSizes(nodes);
      links = [
        { source: "Alpha", target:"Beta", type:"logical" },
        { source: "Beta", target:"Gamma", type:"stochastic" },
        { source: "Gamma", target:"Delta", type:"logical" },
        { source: "Gamma", target:"Epsilon", type:"stochastic" }
      ];
      links.forEach(l => {
        l.source = nodes.find(n=>n.id===l.source);
        l.target = nodes.find(n=>n.id===l.target);
      });

      // build plates and render
      buildPlatesFromNodes();
      recomputePlateBounds();
      updatePlatesSelection();
      drawNodes();
      updateLinksPositions();
      fitToView();
    }
    loadDemo();

    // --- Export menu toggle and exports ---
    const exportBtn = document.getElementById("exportBtn");
    const exportMenu = document.getElementById("exportMenu");
    exportBtn.addEventListener("click", ()=> exportMenu.style.display = exportMenu.style.display === "block" ? "none" : "block");
    window.addEventListener("click", (e)=> {
      if (!exportBtn.contains(e.target) && !exportMenu.contains(e.target)) exportMenu.style.display = "none";
    });

    function serializeSVG() {
      // clone and inline basic attrs for a faithful image
      const clone = svg.node().cloneNode(true);
      clone.setAttribute("xmlns","http://www.w3.org/2000/svg");
      return new XMLSerializer().serializeToString(clone);
    }

    document.getElementById("exportSVG").addEventListener("click", () => {
      const s = serializeSVG();
      const blob = new Blob([s], {type: "image/svg+xml;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "graph.svg"; a.click();
      URL.revokeObjectURL(url);
      exportMenu.style.display = "none";
    });

    document.getElementById("exportPNG").addEventListener("click", () => {
      const s = serializeSVG();
      const blob = new Blob([s], {type: "image/svg+xml;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#fff";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0);
        URL.revokeObjectURL(url);
        canvas.toBlob(b => {
          const pngUrl = URL.createObjectURL(b);
          const a = document.createElement("a");
          a.href = pngUrl; a.download = "graph.png"; a.click();
          URL.revokeObjectURL(pngUrl);
        });
      };
      img.onerror = (e) => { console.error("export image load error", e); URL.revokeObjectURL(url); };
      img.src = url;
      exportMenu.style.display = "none";
    });

    // adjust SVG size on window resize
    window.addEventListener("resize", ()=> {
      width = window.innerWidth - sidebarWidth;
      height = window.innerHeight;
      svg.attr("width", width).attr("height", height);
    });

  </script>
</body>
</html>
